<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ruby on Mike Ball</title><link>/tags/ruby/</link><description>Recent content in ruby on Mike Ball</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 15 Apr 2016 00:00:00 +0000</lastBuildDate><atom:link href="/tags/ruby/index.xml" rel="self" type="application/rss+xml"/><item><title>Using OptionParser in Rake</title><link>/blog/using-optionparser-in-rake/</link><pubDate>Fri, 15 Apr 2016 00:00:00 +0000</pubDate><guid>/blog/using-optionparser-in-rake/</guid><description>Problem: you&amp;rsquo;d like to leverage named arguments in your Ruby Rake task.
Solution: use OptionParser to parse the named arguments. Note the need to also call #OptionParser#order!(ARGV), which is often absent from internet documentation.
This example uses Ruby 2.2.2 and Rake 11.1.2.
require &amp;#39;optparse&amp;#39; task :hello do options = { name: &amp;#39;world&amp;#39; } o = OptionParser.new o.banner = &amp;#34;Usage: rake hello [options]&amp;#34; o.</description></item><item><title>Rails API Integration Tests</title><link>/blog/rails-api-integration-tests/</link><pubDate>Thu, 17 Apr 2014 00:00:00 +0000</pubDate><guid>/blog/rails-api-integration-tests/</guid><description>A web-services-oriented architecture encourages the development of multiple, modular applications over maintaining a single large, all-in-one monolithic piece of software. Often, the web services paradigm involves the development of clients apps that rely upon third party RESTful web services. Labor and responsibilities are divided and conquered across smaller, more manageable codebases and teams. But how can such a client application verify graceful integration? With a large user-base, such insight is increasingly critical.</description></item><item><title>A Simple Ruby Class Example</title><link>/blog/a-simple-ruby-class-example/</link><pubDate>Sun, 30 Mar 2014 00:00:00 +0000</pubDate><guid>/blog/a-simple-ruby-class-example/</guid><description>Some colleagues asked about basic Ruby examples. The following RemoteConfig class makes an HTTP request and provides an object-oriented interface to XML served at the URL requested. The class serves as simple intro to some common needs and Ruby-oriented language features:
dynamic method definition performing GET requests over HTTPS creating a basic, object-oriented interface parsing attribute-heavy XML with XPATH queries testing with Rspec and Webmock The XML Assume the following XML is hosted at https://somedomain.</description></item><item><title>wp2middleman</title><link>/projects/wp2middleman/</link><pubDate>Wed, 15 Jan 2014 00:00:00 +0000</pubDate><guid>/projects/wp2middleman/</guid><description>wp2middleman is a Ruby gem that migrates the Wordpress posts in a Wordpress XML export file to middleman-style markdown files.
wp2middleman provides a wp2mm commandline executable, as well as a WP2Middleman module.
View source and documentation on Github »</description></item><item><title>Lobber</title><link>/projects/lobber/</link><pubDate>Tue, 01 Oct 2013 00:00:00 +0000</pubDate><guid>/projects/lobber/</guid><description>Lobber is a simple command line utility used to quickly upload a directory to Amazon S3.
Lobber is built with Ruby and can be downloaded from Rubygems.
View its source code on GitHub »</description></item><item><title>Streamlined Rails Gem Updates on Gem in a Box</title><link>/blog/streamlined-rails-gem-updates-on-gem-in-a-box/</link><pubDate>Mon, 11 Feb 2013 00:00:00 +0000</pubDate><guid>/blog/streamlined-rails-gem-updates-on-gem-in-a-box/</guid><description>Problem: Per recent Ruby on Rails security patches, you need to update your Rails applications. However, because you host Rails and its related gems on a private Gem in a Box gem server, it’s a bit cumbersome to manually download the necessary gems from Rubygems.org, and then upload them to your Gem in a Box gem server.
Solution: bash and curl.
1. List the necessary gems in a gems.txt file:</description></item><item><title>Using the phl_geocode Ruby Gem</title><link>/blog/using-the-phl_geocode-ruby-gem/</link><pubDate>Mon, 17 Dec 2012 00:00:00 +0000</pubDate><guid>/blog/using-the-phl_geocode-ruby-gem/</guid><description>I recently released phl_geocode, a simple Ruby gem which gets latitude and longitude coordinates for a Philadelphia address.
Getting Started Install phl_geocode:
gem install phl_geocode Require phl_geocode:
require &amp;#34;phl_geocode&amp;#34; Instantiate a PHLGeocode instance:
phl = PHLGeocode.new Get latitude/longitude coordinates for a Philadelphia address:
phl.get_coordinates &amp;#34;1500 market street&amp;#34; Example response:
[{ :address =&amp;gt; &amp;#34;1500 MARKET ST&amp;#34;, :similarity =&amp;gt; 100, :latitude =&amp;gt; 39.</description></item><item><title>Lobbying.ph</title><link>/blog/lobbying.ph/</link><pubDate>Mon, 05 Mar 2012 00:00:00 +0000</pubDate><guid>/blog/lobbying.ph/</guid><description>Update: Casey Thomas migrated the original Lobbing.ph to Django and extended its functionality.
Casey Thomas, Dan Freiman, Adam Hinz, and I build Lobbying.ph as an entry in Code for America&amp;rsquo;s 2012 Civic Hackathon in Philadelphia. The project won first place.
Completed in about 5 hours, Lobbying.ph seeks to help Philadelphians access information about local lobbying efforts. As is reported on the site:
&amp;ldquo;Beginning in 2012, lobbyists and those paying for lobbyists in Philadelphia are required to register and file quarterly reports of their expenses with the City of Philadelphia Board of Ethics.</description></item></channel></rss>