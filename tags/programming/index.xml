<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on Mike Ball</title><link>http://mikeball.info/tags/programming/</link><description>Recent content in programming on Mike Ball</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 20 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://mikeball.info/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Concurrency With Goroutines and Channels</title><link>http://mikeball.info/blog/go-concurrency-with-goroutines-and-channels/</link><pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate><guid>http://mikeball.info/blog/go-concurrency-with-goroutines-and-channels/</guid><description>Some introductory notes on Go concurrency, goroutines, and channels, largely serving as a slightly-more-indepth supplement to a brief 2018 overview and example.
Goroutines Normally, calling a function — foo(), for example — is a blocking operation. This means that program execution waits for it to finish before proceeding.
However, invoking a function with the go keyword — go foo(), for example — is non-blocking. When invoked as go foo(), Go runs foo() as a separate task managed by Go.</description></item></channel></rss>