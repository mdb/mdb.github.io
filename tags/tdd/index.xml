<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tdd on Mike Ball</title><link>/tags/tdd/</link><description>Recent content in tdd on Mike Ball</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 30 Mar 2014 00:00:00 +0000</lastBuildDate><atom:link href="/tags/tdd/index.xml" rel="self" type="application/rss+xml"/><item><title>A Simple Ruby Class Example</title><link>/blog/a-simple-ruby-class-example/</link><pubDate>Sun, 30 Mar 2014 00:00:00 +0000</pubDate><guid>/blog/a-simple-ruby-class-example/</guid><description>Some colleagues asked about basic Ruby examples. The following RemoteConfig class makes an HTTP request and provides an object-oriented interface to XML served at the URL requested. The class serves as simple intro to some common needs and Ruby-oriented language features:
dynamic method definition performing GET requests over HTTPS creating a basic, object-oriented interface parsing attribute-heavy XML with XPATH queries testing with Rspec and Webmock The XML Assume the following XML is hosted at https://somedomain.</description></item><item><title>Automated Tests: What, Why, How?</title><link>/blog/automated-tests-what-why-how/</link><pubDate>Sat, 08 Feb 2014 00:00:00 +0000</pubDate><guid>/blog/automated-tests-what-why-how/</guid><description>In recent years, automated testing has gained significant traction as a software development best practice. But not everyone&amp;rsquo;s sold or fully understands where to begin in developing such tests.
Some teams fear test-writing may impact velocity. Some believe an ill-designed, legacy codebase makes such tests impossible. Others don&amp;rsquo;t fully grasp the benefits. And others simply don&amp;rsquo;t know where to begin.
I&amp;rsquo;m frequently asked about automated testing — managers, product owners, UX designers, junior developers, and the uninitiated want to know: Why write tests?</description></item><item><title>Testing Node.js with Mocha, Expect.js, and Nock</title><link>/blog/testing-node.js-with-mocha-expect.js-and-nock/</link><pubDate>Fri, 12 Oct 2012 00:00:00 +0000</pubDate><guid>/blog/testing-node.js-with-mocha-expect.js-and-nock/</guid><description>Problem: Your Node.js code uses request or http to make http requests to URLs. You don’t want to make actual http calls, nor do you want to test request and/or http. How can you test that your code works as intended and interfaces properly with request and http?
Solution: Use nock. For the purposes of this example, I’ll also demonstrate how nock works in concert with mocha and expect.js.
Your node module // Let&amp;#39;s call this file/module flickr-feeder.</description></item><item><title>Using Mocha to Test a Node.js Server</title><link>/blog/using-mocha-to-test-a-node.js-server/</link><pubDate>Wed, 15 Aug 2012 00:00:00 +0000</pubDate><guid>/blog/using-mocha-to-test-a-node.js-server/</guid><description>How do you write Mocha tests against a Node.js server and run the tests during development, presumably while your server is already running?
Solution: Leverage fork to run the server code as a child process of the Mocha test. The following is a quick example of what this could look like.
The Server Code Let&amp;rsquo;s assume this code lives in your-project/server.js.
var http = require(&amp;#39;http&amp;#39;); var util = require(&amp;#39;util&amp;#39;); var port = process.</description></item><item><title>How to Make Testable Private Methods in JavaScript</title><link>/blog/how-to-make-testable-private-methods-in-javascript/</link><pubDate>Wed, 11 May 2011 00:00:00 +0000</pubDate><guid>/blog/how-to-make-testable-private-methods-in-javascript/</guid><description>Problem: how to write unit tests for private functions?
As my co-worker Trevor suggests in more detail, one solution is to create a class with 3 internal objects:
settings: this object houses configuration options, such as a debug option private: this object houses private functions public: this object houses all public functions Then, in writing unit tests, a developer can instantiate the class by passing {debug: true} to adjust the class&amp;rsquo;s settings such that the private and public objects are merged, in effect exposing the previously private functions housed in the private object.</description></item></channel></rss>