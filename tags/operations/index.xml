<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>operations on Mike Ball</title><link>/tags/operations/</link><description>Recent content in operations on Mike Ball</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 18 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/operations/index.xml" rel="self" type="application/rss+xml"/><item><title>A systemd Cheat Sheet</title><link>/blog/a-systemd-cheat-sheet/</link><pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate><guid>/blog/a-systemd-cheat-sheet/</guid><description>Generally, systemd is the standard init system across Linux distributions. systemctl is its central CLI management tool. This is a brief overview and cheat sheet.
Background systemd is responsible for initializing and managing components, services, and daemons that must be started after the kernel is booted. Such components are often referred to as &amp;ldquo;userland&amp;rdquo; components. resources managed by systemd are called units; these are defined in unit files service management unit files are suffixed with a .</description></item><item><title>Using wget over Ansible's get_url</title><link>/blog/using-wget-over-ansibles-get_url/</link><pubDate>Wed, 23 Dec 2015 00:00:00 +0000</pubDate><guid>/blog/using-wget-over-ansibles-get_url/</guid><description>Problem: In provisioning a server, your Ansible playbook needs to download files from a URL behinded authentication, such as a private GitHub repository. In Ansible 2.0, Ansible&amp;rsquo;s get_url supports custom headers — such as Authorization — but pre-2.0 Ansible does not.
Solution: Use wget, a wgetrc, and ansible-vault.
Step 1: Generate a GitHub access token
Step 2: Store the token in an Ansible group_var at your_playbook_dir/group_vars/all:
github_token: &amp;#34;your access token value&amp;#34; Step 3: Use ansible-vault to encrypt your github_token; enter a password at the prompt:</description></item><item><title>Apache Persistent Connection Problems</title><link>/blog/apache-persistent-connection-problems/</link><pubDate>Sun, 18 Oct 2015 00:00:00 +0000</pubDate><guid>/blog/apache-persistent-connection-problems/</guid><description>Problem: Apache worker thread pool is exhausted; server CPU consumption is high.
Solution: reduce the Apache KeepAliveTimeout from its 15 second default (disclaimer: maybe, depending on circumstances).
Background HTTP keep-alive functionality seeks to improve efficiency. In effect, HTTP keep-alive — also referred to as HTTP persistent connection and HTTP connection reuse allows the use of a single TCP connection to send and receive multiple HTTP requests and responses.
Keep-alive reduces the latency associated with opening a new TCP connection for each HTTP request.</description></item></channel></rss>