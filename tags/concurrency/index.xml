<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>concurrency on Mike Ball</title><link>http://mikeball.info/tags/concurrency/</link><description>Recent content in concurrency on Mike Ball</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 11 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://mikeball.info/tags/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Test Parallelization</title><link>http://mikeball.info/blog/go-test-parallelization/</link><pubDate>Fri, 11 Jun 2021 00:00:00 +0000</pubDate><guid>http://mikeball.info/blog/go-test-parallelization/</guid><description>A brief introduction to using Go&amp;rsquo;s testing package&amp;rsquo;s T.Parallel() to parallelize tests.
Problem Your Go project&amp;rsquo;s tests are slow and run serially. Or perhaps they&amp;rsquo;re not slow, but they run serially and could be faster.
Solution Consider running the test cases in parallel.
Simple non-parallelized example As a starting point, consider a simple non-parallelized test:
package main import ( &amp;#34;io/ioutil&amp;#34; &amp;#34;os&amp;#34; &amp;#34;testing&amp;#34; &amp;#34;time&amp;#34; ) func TestSimple(t *testing.</description></item><item><title>Go Concurrency With Goroutines and Channels</title><link>http://mikeball.info/blog/go-concurrency-with-goroutines-and-channels/</link><pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate><guid>http://mikeball.info/blog/go-concurrency-with-goroutines-and-channels/</guid><description>Some introductory notes on Go concurrency, goroutines, and channels, largely serving as a slightly-more-indepth supplement to a brief 2018 overview and example.
Goroutines Normally, calling a function — foo(), for example — is a blocking operation. This means that program execution waits for it to finish before proceeding.
However, invoking a function with the go keyword — go foo(), for example — is non-blocking. When invoked as go foo(), Go runs foo() as a separate task managed by Go.</description></item><item><title>Channels in Go</title><link>http://mikeball.info/blog/channels-in-go/</link><pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate><guid>http://mikeball.info/blog/channels-in-go/</guid><description>Through goroutines and channels, Go offers constructs for concurrent programming. A goroutine is a concurrent function execution, while a channel offers a communication mechanism through which one goroutine can pass values of a specific type to another goroutine.
For example, the following code performs three HTTP requests concurrently, reports back the request URL, the request response time, and its HTTP response status code for each request, and also the total time spent executing the program.</description></item></channel></rss>