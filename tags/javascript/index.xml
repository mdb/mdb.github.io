<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on Mike Ball</title><link>/tags/javascript/</link><description>Recent content in javascript on Mike Ball</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 04 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Collecting Paginated HTTP API Response Data Using JavaScript's async/await</title><link>/blog/collecting-paginated-http-api-response-data-using-javascripts-async/await/</link><pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate><guid>/blog/collecting-paginated-http-api-response-data-using-javascripts-async/await/</guid><description>Collecting all pages of data from a paginated HTTP API can be a bit tricky in JavaScript, especially for developers who are less familiar with asynchronous JavaScript&amp;rsquo;s nuances. The following offers a reference example using JavaScript&amp;rsquo;s async/await.
Problem You need to fetch all pages of data from a paginated HTTP API in JavaScript; you&amp;rsquo;d like to do so using fetch, and you&amp;rsquo;d like to leverage async/await. While this is a relatively common scenario, how best to tackle it in JavaScript using async/await is a bit tricky.</description></item><item><title>Mocking aws-sdk With Jest</title><link>/blog/mocking-aws-sdk-with-jest/</link><pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate><guid>/blog/mocking-aws-sdk-with-jest/</guid><description>A technique for mocking aws-sdk methods with jest without the use of aws-sdk-mock.
Problem Your Node.js application uses the aws-sdk NPM module via functions like getEksClusterCount, for example:
import AWS from &amp;#39;aws-sdk&amp;#39;; const export getEksClusterCount = async () =&amp;gt; { const eks = new AWS.EKS(); try { const clusters = await eks.listClusters().promise(); return clusters.length; catch (e) { throw e; } }; How can getEksClusterCount&amp;rsquo;s use of AWS.EKS be mocked out for unit testing?</description></item><item><title>How to Test Google Polymer elements on Travis CI</title><link>/blog/how-to-test-google-polymer-elements-on-travis-ci/</link><pubDate>Sat, 06 Jun 2015 00:00:00 +0000</pubDate><guid>/blog/how-to-test-google-polymer-elements-on-travis-ci/</guid><description>Problem: how do you design a cloud-based continuous integration pipeline if your automated application tests relies on technology that requires a GUI, or an actual web browser? Google Polymer heavily leverages Shadow DOM, a feature that&amp;rsquo;s not currently supported in headless JavaScript environments like PhantomJS. My polymer-testing-box demonstrate how to run such tests via Xvfb on a headless Ubuntu VM. Can this technique be used on Travis CI?
Travis CI supports Xvfb and Firefox.</description></item><item><title>Using Google Spreadsheets and Tabletop.js as a Web Application Back-end</title><link>/blog/using-google-spreadsheets-and-tabletop.js-as-a-web-application-back-end/</link><pubDate>Sat, 02 Mar 2013 00:00:00 +0000</pubDate><guid>/blog/using-google-spreadsheets-and-tabletop.js-as-a-web-application-back-end/</guid><description>At NICAR 2013, Tasneem Raja spoke on Smarter interactive Web projects with Google Spreadsheets and Tabletop.js. Tasneem is Mother Jones‘s Interactive Editor; she outlined how Mother Jones uses Google Spreadsheets to power some of its interactive features.
Beyond serving as a simple, easy-to-maintain datastore and CMS, Google Spreadsheets — used in concert with Tabletop.js — allows for the creation of dynamic web content in absence of server-side processing, in effect empowering a highly scalable and simple architecture.</description></item><item><title>Using the civic-info Node.js Module to Get Voter and Election Info</title><link>/blog/using-the-civic-info-node.js-module-to-get-voter-and-election-info/</link><pubDate>Thu, 08 Nov 2012 00:00:00 +0000</pubDate><guid>/blog/using-the-civic-info-node.js-module-to-get-voter-and-election-info/</guid><description>Inspired by election apps like vote, I wrote civic-info.js, a simple Node.js module to interface with Google&amp;#8217;s Civic Info API.
## Getting Started 1. Secure a Google API key. 2. Install civic-info:
npm install civic-info 3. Require and instantiate civic-info with your Google API key:
var civicInfo = require(&amp;#34;civic-info&amp;#34;)({apiKey: &amp;#34;YOUR KEY&amp;#34;}); Alteratively, you can set a GOOGLE_API_KEY environment variable and instantiate like so:
var civicInfo = require(&amp;#34;civic-info&amp;#34;)(); Examples Get election info and election IDs:</description></item><item><title>Deploying an Express App to Heroku</title><link>/blog/deploying-an-express-app-to-heroku/</link><pubDate>Mon, 22 Oct 2012 00:00:00 +0000</pubDate><guid>/blog/deploying-an-express-app-to-heroku/</guid><description>Some coworkers expressed interest in deploying Express apps to Heroku. These instructions seek to provide a basic overview, though Heroku offers much more robust documentation in its dev center.
Step 1: Create a Heroku account.
Step 2: Install the Heroku Toolbelt, which includes the Heroku command line client, Git, and Foreman.
Step 3: Log in by entering the following in the command line:
heroku login Step 4: Install Node.js.
Step 5: Create an Express app.</description></item><item><title>Testing Node.js with Mocha, Expect.js, and Nock</title><link>/blog/testing-node.js-with-mocha-expect.js-and-nock/</link><pubDate>Fri, 12 Oct 2012 00:00:00 +0000</pubDate><guid>/blog/testing-node.js-with-mocha-expect.js-and-nock/</guid><description>Problem: Your Node.js code uses request or http to make http requests to URLs. You don’t want to make actual http calls, nor do you want to test request and/or http. How can you test that your code works as intended and interfaces properly with request and http?
Solution: Use nock. For the purposes of this example, I’ll also demonstrate how nock works in concert with mocha and expect.js.
Your node module // Let&amp;#39;s call this file/module flickr-feeder.</description></item><item><title>Using Mocha to Test a Node.js Server</title><link>/blog/using-mocha-to-test-a-node.js-server/</link><pubDate>Wed, 15 Aug 2012 00:00:00 +0000</pubDate><guid>/blog/using-mocha-to-test-a-node.js-server/</guid><description>How do you write Mocha tests against a Node.js server and run the tests during development, presumably while your server is already running?
Solution: Leverage fork to run the server code as a child process of the Mocha test. The following is a quick example of what this could look like.
The Server Code Let&amp;rsquo;s assume this code lives in your-project/server.js.
var http = require(&amp;#39;http&amp;#39;); var util = require(&amp;#39;util&amp;#39;); var port = process.</description></item><item><title>Fluent 2012 Notes: Nicholas Zakas on Maintainable JavaScript</title><link>/blog/fluent-2012-notes-nicholas-zakas-on-maintainable-javascript/</link><pubDate>Thu, 31 May 2012 00:00:00 +0000</pubDate><guid>/blog/fluent-2012-notes-nicholas-zakas-on-maintainable-javascript/</guid><description>My notes from Nicholas Zakas&amp;rsquo;s 2012 Fluent talk on Maintainable JavaScript.
The primary features of maintainable code:
works for at least 5 years without major changes intuitive understandable adaptable - developers must be able to change without breaking completely extendable - the code can be built upon to do more than was originally intended debuggable - developers should be able to easily identify the source of problems testable - code that can be validated with unit tests saves time and ensures quality Maintainability requires coordination.</description></item><item><title>How to Make Testable Private Methods in JavaScript</title><link>/blog/how-to-make-testable-private-methods-in-javascript/</link><pubDate>Wed, 11 May 2011 00:00:00 +0000</pubDate><guid>/blog/how-to-make-testable-private-methods-in-javascript/</guid><description>Problem: how to write unit tests for private functions?
As my co-worker Trevor suggests in more detail, one solution is to create a class with 3 internal objects:
settings: this object houses configuration options, such as a debug option private: this object houses private functions public: this object houses all public functions Then, in writing unit tests, a developer can instantiate the class by passing {debug: true} to adjust the class&amp;rsquo;s settings such that the private and public objects are merged, in effect exposing the previously private functions housed in the private object.</description></item><item><title>JavaScript Design Patterns</title><link>/blog/javascript-design-patterns/</link><pubDate>Sat, 19 Mar 2011 00:00:00 +0000</pubDate><guid>/blog/javascript-design-patterns/</guid><description>Addy Osmani offers Essential JavaScript &amp;amp; jQuery Design Patterns For Beginners as a free guide to some solutions &amp;ldquo;that can be applied to commonly occurring problems&amp;rdquo; throughout JavaScript. Here are a few of my notes on Osmani’s book, mostly for my own reference:
The Creational Pattern used in creating objects within in application define a class and instantiate it later when you need it var newObject = new MyClass(); The Constructor Function used to create specific types of objects native constructors in JavaScript include Array and Object constructor functions often capitalized to distinguish them from normal functions function Car(model, year, miles){ this.</description></item><item><title>free103point9</title><link>/projects/free103point9/</link><pubDate>Tue, 23 Feb 2010 00:00:00 +0000</pubDate><guid>/projects/free103point9/</guid><description>Gabe Farrell and I developed this site for the New York-based transmission arts advocacy organization free103point9.
The site is built on Django. In addition to brochuring free103point9, the site also serves as a transmission arts digital archive, hosts an event calendar, and houses free103′s online radio station.</description></item></channel></rss>