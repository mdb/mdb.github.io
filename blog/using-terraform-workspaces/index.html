<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Using Terraform workspaces | Mike Ball</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=generator content="Hugo 0.101.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/main.min.ade9986381ae22db9663db02b239a9a46cd1222e56e0effc0119f6ad2c3ef1cc.css></head><body class=blog-post><header><div class=mark><a href=/>Mike Ball</a></div><button>Toggle Navigation</button><div class=nav-wrap><nav class=primary><ul><li><a href=/blog>Blog</a></li><li><a href=#about>About</a></li></ul></nav><nav class=secondary><ul><li><a href=https://github.com/mdb>GitHub</a></li><li><a href=https://instagram.com/clapclapexcitement>Instagram</a></li></ul></nav><nav class=tertiary><ul><li><a href=https://tiendah.bigcartel.com>Shop</a></li><li><a href=#about>Contact</a></li></ul></nav></div></header><main role=main><div class=blog-post><aside class=divider><a href=/blog/>Blog</a></aside><time>April 25, 2021</time><article><header><h1>Using Terraform workspaces</h1></header><div><p><strong>Problem</strong>: In distributed software engineering, it&rsquo;s common to maintain multiple named <em>environments</em>, each of which is a distinct, logical grouping of infrastructure resources. For example, utilizing separate <code>production</code> and <code>pre-production</code> environments (<code>staging</code>, <code>development</code>, etc.) is a traditional multi-tiered environment strategy in structuring a phased software build, test, and release lifecycle (or even a phased approach in deploying the software <em>infrastructure</em> itself). But how can a single <a href=https://terraform.io>Terraform</a> configuration be used to safely manage infrastructure resources spanning multiple parallel environments? What are techniques for adequately isolating Terraform actions against one environment such that other environments aren&rsquo;t inadvertently modified? How might the traditional, somewhat coarse-grained multi-tiered environment structure present Terraform management challenges in some circumstances?</p><p><strong>Solution</strong>: Sufficiently granular and descriptively named Terraform <a href=https://www.terraform.io/docs/state/workspaces.html><em>workspaces</em></a> may help.</p><h2 id=introduction-to-terrraform-workspaces>Introduction to Terrraform workspaces</h2><p>Through the use of <a href=https://www.terraform.io/docs/state/workspaces.html><em>workspaces</em></a>, Terraform empowers the ability to create multiple, logical groupings of resources &ndash; each associated with its own, independent <a href=https://www.terraform.io/docs/state/purpose.html>state</a> &ndash; from a single Terraform configuration.</p><p>According to the Terraform documentation:</p><blockquote><p>Each Terraform configuration has an associated <a href=https://www.terraform.io/docs/backends/index.html>backend</a> that defines how operations are executed and where persistent data such as <a href=https://www.terraform.io/docs/state/purpose.html>the Terraform state</a> are stored.</p></blockquote><blockquote><p>Workspaces are managed with the <code>terraform workspace</code> set of commands. To create a new workspace and switch to it, you can use <code>terraform workspace new</code>; to switch workspaces you can use <code>terraform workspace select</code>; etc.</p></blockquote><p>Despite that named workspaces &ldquo;allow conveniently switching between multiple instances of a single configuration,&rdquo; the use of workspaces is often overlooked in favor of homegrown patterns. For example, it&rsquo;s common practice to separate Terraform configurations across directories within a code repository, where each directory&rsquo;s <code>*.tf</code> contents pertains to a named environment (<code>production</code>, <code>development</code>, etc.), has its own state, and can by applied independently. Similarly, it&rsquo;s also common to adopt the use of a Terraform <code>var.environment</code> variable to apply different configuration based on the <code>var.environment</code> variable&rsquo;s value.</p><p>However, depending on perspective, Terraform&rsquo;s built-in concept of workspaces may offer advantages over homegrown techniques for isolating logical groupings of Terraform resources across environments.</p><p>Specifically, a few arguable advantages of workspaces include:</p><ol><li>Out of the box state isolation</li><li>Creating and managing infinite new environments is relatively low effort</li><li>Code DRY-ness and simplicity</li><li>Simple feature flag capabilities</li></ol><h3 id=1-out-of-the-box-state-isolation>1. Out of the box state isolation</h3><p>Terraform stores a configuration&rsquo;s remote state in a unique location based on its workspace. In other words, each named workspace has its own, isolated state that is sandboxed from that of other workspaces.</p><p>For example, given the following backend state declaration using Amazon S3 as its remote state backend&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>terraform</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>backend</span> <span style=color:#e6db74>&#34;s3&#34;</span> {
</span></span><span style=display:flex><span>    bucket <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;my-team-state&#34;</span>
</span></span><span style=display:flex><span>    key    <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;my-service/terraform.tfstate&#34;</span>
</span></span><span style=display:flex><span>    region <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;us-east-1&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr;Terraform automatically creates a unique, isolated per-workspace <code>terraform.tfstate</code> file in S3 at each named workspace-specific path:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>my-team-state/:env/${workspace name}/my-service/terraform.tfstate
</span></span></code></pre></div><p>(If no named workspace is explicitly selected via <code>terraform workspace select ${workspace}</code>, Terraform uses the <code>default</code> workspace and its corresponding <code>my-team-state/:env/default/my-service/terraform.tfstate</code> S3 path.)</p><p>Through the use of workspaces, Terraform offers out-of-the-box state isolation; it&rsquo;s not necessary to explicitly declare multiple, per-environment state backend configurations. The use of workspaces also ensure it&rsquo;s less likely the application of one workspace&rsquo;s configuration will impact another workspace&rsquo;s resources and/or state.</p><h3 id=2-creating-and-managing-infinite-new-environments-is-relatively-low-effort>2. Creating and managing infinite new environments is relatively low effort</h3><p>By adopting the use of named Terraform workspaces when applying a Terraform configuration, the configuration can be applied against an infinite number of unique, isolated workspaces. In effect, the use of Terraform workspaces makes it less necessary to initially identify and codify configuration for a finite number of known environments &ndash; <code>production</code>, <code>staging</code>, and <code>dev</code>, for example &ndash; and empowers the low effort management of an infinite number of far more granular parallel environments created from common configuration. This may be particularly beneficial in facilitating the management of short-lived and ephemeral environments, as might be helpful in development or when performing A/B tests, progressive rollouts, or even incremental infrastructure migrations.</p><h3 id=3-code-dry-ness-and-simplicity>3. Code DRY-ness and simplicity</h3><p>Additionally, Terraform workspaces arguably reduce the need to repeat Terraform configuration for each environment. Instead, a single Terraform configuration can be applied against multiple workspaces. Through the use of workspaces, it&rsquo;s not necessary to maintain per-environment directories and/or multiple, repetitive, per-environment module instantiations or state backend configurations. The use of workspaces also reduces the need to use a <code>var.environment</code> variable; <code>terraform.workspace</code> can be used intead. In this sense, the use of Terraform workspaces may reduce code complexity, redundant configurations, and thereby maintenance challenges.</p><h3 id=4-simple-feature-flag-capabilities>4. Simple feature flag capabilities</h3><p>Terraform workspaces also offer a mechanism through which conditional logic can enable or disable certain infrastructure features or attributes based on the workspace.</p><p>For example, the following Terraform only creates a <code>aws_s3_bucket.my_bucket</code> resource when applied against the <code>dev</code> workspace:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_s3_bucket&#34; &#34;my_bucket&#34;</span> {
</span></span><span style=display:flex><span>  count  <span style=color:#f92672>=</span> terraform.workspace <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;dev&#34;</span> <span style=color:#960050;background-color:#1e0010>?</span> <span style=color:#ae81ff>1</span> <span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  bucket <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;my-bucket&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Workspace-based feature flags can be particularly useful when incrementally deploying features across workspaces in a <a href=https://martinfowler.com/bliki/CanaryRelease.html>canary</a> fashion, or in dividing <em>implementation</em> and <em>application</em> across multiple phases. By enabling &ldquo;<a href=https://en.wikipedia.org/wiki/NOP_(code)>NOOP</a>&rdquo; code changes, workspace-based feature flags may also be helpful when practicing a model of <a href=https://en.wikipedia.org/wiki/Continuous_delivery>continuous delivery</a> in which small, iterative changes to Terraform configuration are frequently introduced to a repository&rsquo;s main branch and continuously applied.</p><p>While such feature flagging capabilities are certainly possible without utilizing Terraform workspaces, workspaces may prove helpful in facilitating a relatively simple implementation pattern.</p><h2 id=how-should-workspaces-be-modeled-and-named>How should workspaces be modeled and named?</h2><p>When no explicitly named workspace is selected via <code>terraform workspace select</code>, Terraform uses a <code>default</code> workspace, as is explained by Terraform&rsquo;s documentation:</p><blockquote><p>The persistent data stored in the backend belongs to a <em>workspace</em>. Initially the backend has only one workspace, called “default”, and thus there is only one Terraform state associated with that configuration.</p></blockquote><p>However, because the use of non-<code>default</code> and explicitly named workspaces enables more granular resource groupings and associated state, a configuration&rsquo;s Terraform actions can safely and easily target subsets of Terraform-managed infrastructure without broader impact. The <code>terraform.workspace</code> can also be used &ndash; often in alternative to a <code>var.environment</code> &ndash; to uniquely name and tag Terraform-managed resources. This further ensures workspace resource isolation, makes infrastructure self-descriptive, and also makes cloud resources queryable across workspace names.</p><p>So, ideally, workspace names should be sufficiently descriptive of the collection of resources associated with the workspace. But how?</p><h2 id=basic-naming-convention>Basic naming convention</h2><p>In basic scenarios, workspace names mapping to traditional, multi-tiered environments may suffice. For example:</p><ul><li><code>pull-request</code></li><li><code>development</code></li><li><code>staging</code></li><li><code>production</code></li></ul><h2 id=advanced-naming-convention>Advanced naming convention</h2><p>But what about more advanced scenarios? What about scenarios where a <code>production</code> environment consists of resources across multiple AWS regions, each of which should be applied in isolation? Or even across multiple cloud providers, each of which should be applied in isolation? Or what about when an environment consists of independent <code>blue</code> and <code>green</code> stacks in the case of a <a href=https://martinfowler.com/bliki/BlueGreenDeployment.html>blue/green deployment</a>? Or an independent <a href=https://martinfowler.com/bliki/CanaryRelease.html>canary stack</a> in the case of an incremental rampup-style deployment? How can Terraform actions target subsets of complex infrastructure environments, ensuring against scenarios where a problematic Terraform action has broad reach beyond its intended field of impact?</p><p>For these more advanced landscapes, a logical environment (<code>production</code>, <code>staging</code>, etc.) may consist of <em>multiple</em>, independent workspaces, each of which maps to its own, independent state. For such scenarios, a more advanced, multi-part workspace-naming convention may be worth considering. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>${env}-${provider}-${region}-${an optional unique identifier if necessary}
</span></span></code></pre></div><h3 id=what-does-each-part-signify>What does each part signify?</h3><ul><li><code>${env}</code> - the logical environment. For example: prod, staging, dev</li><li><code>${provider}</code> - the cloud provider. For example: aws, openstack, digitalocean</li><li><code>${region}</code> - the region in which the workspace infrastructure lives. For example: us-east-1, us-west-2</li><li><code>${an optional unique identifier}</code> - an optional, more granular unique identifier, if necessary. For example: blue, green, a, b, or even a <code>${GIT_SHA}</code></li></ul><h3 id=some-real-world-examples>Some real world examples:</h3><ul><li><code>staging-aws-us-west-2</code></li><li><code>production-aws-us-east-1</code></li><li><code>production-aws-us-east-1-blue</code></li><li><code>production-aws-us-east-1-green</code></li><li><code>production-aws-us-east-1-5fe7bsa</code></li></ul><h2 id=examples-in-use>Examples in use</h2><p>In addition to empowering the ability to execute Terraform actions against a targeted subset of infrastructure without broader impact, sufficiently granular workspaces also enable per-workspace variables and the ability to declare more nuanced configuration differences between workspaces.</p><h3 id=per-workspace-variable-values>Per-workspace variable values</h3><p>For example, consider the following HCL declaring per-workspace AWS RDS instance class values&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>variable</span> <span style=color:#e6db74>&#34;rds_instance_class&#34;</span> {
</span></span><span style=display:flex><span>  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;The size of the AWS RDS instance size per workspace&#34;</span>
</span></span><span style=display:flex><span>  type        <span style=color:#f92672>=</span> <span style=color:#66d9ef>map</span>(<span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  default <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    staging-aws-us-east-1    <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;db.t3.micro&#34;</span>
</span></span><span style=display:flex><span>    production-aws-us-east-1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;db.m5.8xlarge&#34;</span>
</span></span><span style=display:flex><span>    production-aws-us-west-2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;db.m5.8xlarge&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr;which allows the selection of workspace-specific values from a single Terraform configuration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_db_instance&#34; &#34;rds&#34;</span> {
</span></span><span style=display:flex><span>  instance_class <span style=color:#f92672>=</span> <span style=color:#66d9ef>var</span>.<span style=color:#66d9ef>rds_instance_class</span>[<span style=color:#66d9ef>terraform</span>.<span style=color:#66d9ef>workspace</span>]
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>But isn&rsquo;t that a lot of variable repetition for scenarios where <code>rds_instance_class</code> is the same across all <code>prod-*</code> workspaces? How might the code be further improved? The use of a <a href=https://www.terraform.io/docs/configuration/locals.html>Terraform local</a> to select the <code>environment</code> from the multi-part workspace name enables DRY-ness.</p><p>For example, to an extract a <code>local.environment</code> from the <code>terraform.workspace</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>locals</span> {<span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>  # The &#39;logical&#39; environment name (prod, staging, dev etc.)
</span></span></span><span style=display:flex><span><span style=color:#75715e>  # taken from the terraform.workspace (prod-aws-us-east-1, for example)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  environment <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;${split(&#34;-&#34;, terraform.workspace)[0]}&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, the <code>rds_instance_class</code> values can be collapsed to two per-<code>environment</code> values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>variable</span> <span style=color:#e6db74>&#34;rds_instance_class&#34;</span> {
</span></span><span style=display:flex><span>  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;The size of the AWS RDS instance size per env&#34;</span>
</span></span><span style=display:flex><span>  type        <span style=color:#f92672>=</span> <span style=color:#66d9ef>map</span>(<span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  default <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    staging    <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;db.t3.micro&#34;</span>
</span></span><span style=display:flex><span>    production <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;db.m5.8xlarge&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In turn, this allows a single Terraform configuration to select and deploy <code>env</code>-specific values common to all workspaces in a given <code>env</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_db_instance&#34; &#34;rds&#34;</span> {
</span></span><span style=display:flex><span>  instance_class <span style=color:#f92672>=</span> <span style=color:#66d9ef>var</span>.<span style=color:#66d9ef>rds_instance_class</span>[<span style=color:#66d9ef>local</span>.<span style=color:#66d9ef>environment</span>]
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Alternatively, maybe it&rsquo;s unnecessary to expose the ability to specify
<code>instance_class</code> via a variable <em>at all</em>; perhaps the <code>var.rds_instance_class</code>
can be removed entirely in favor of a private <code>local</code> variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>locals</span> {<span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>  # The &#39;logical&#39; environment name (prod, staging, dev etc.)
</span></span></span><span style=display:flex><span><span style=color:#75715e>  # taken from the terraform.workspace (prod-aws-us-east-1, for example)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  environment <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;${split(&#34;-&#34;, terraform.workspace)[0]}&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  rds_instance_class <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    staging    <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;db.t3.micro&#34;</span>
</span></span><span style=display:flex><span>    production <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;db.m5.8xlarge&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_db_instance&#34; &#34;rds&#34;</span> {
</span></span><span style=display:flex><span>  instance_class <span style=color:#f92672>=</span> <span style=color:#66d9ef>local</span>.<span style=color:#66d9ef>rds_instance_class</span>[<span style=color:#66d9ef>local</span>.<span style=color:#66d9ef>environment</span>]
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=summary>Summary</h2><p>In summary, the use of <a href=https://www.terraform.io/docs/language/state/workspaces.html>Terraform workspaces</a> &ndash; as well as the adoption of a sufficiently granular workspaces &ndash; may help facilitate logical and safe multi-environment Terraform practices and code simplification.</p></div><ul class=tags><li><a href=/tags/terraform>terraform</a></li><li><a href=/tags/infrastructure>infrastructure</a></li><li><a href=/tags/cloud>cloud</a></li></ul></article></div></main><footer><section><h1 id=about>Info</h1><div><h2>Mike Ball</h2><p>I live in Philadelphia and work as a multi-disciplinary software engineer & designer.</p><p>Over the years, I've developed front end web applications, built backend services, automated cloud infrastructure management, designed CI/CD pipelines for high scale distributed systems, and contributed to numerous open source software projects.</p><p>I've also worked in graphic and UX design. Buy prints of my illustrations at <a href=https://tiendah.bigcartel.com>Tiendah</a>.</div><div class=double><h2>Shop Tiendah</h2><ul class="gallery store-feed"></ul><h2>Instagram</h2><ul class="gallery ig-feed"></ul></div><div><h2>Etc.</h2><ul><li><a href=http://github.com/mdb>GitHub</a></li><li><a href=http://twitter.com/clapexcitement>Twitter</a></li><li><a href=https://instagram.com/clapclapexcitement>Instagram</a></li><li><a href=/index.xml>RSS Feed</a></li><li><a href=https://tiendah.bigcartel.com>Shop Tiendah</a></li></ul><h2>Contact</h2><p>Interested in working with me? <a href=mailto:mikedball@gmail.com>Get in touch</a>.</p></div></section></footer><script type=text/javascript src=/js/main.min.293095ab78ab0063790d59dc6e7fd31835bb02930d51ededffd136ed11be427f.js></script>
<script type=text/javascript>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-54324621-1","auto"),ga("send","pageview")</script></body></html>